    <script>
        // å…¨å±€å˜é‡
        let currentDays = Number(document.body?.dataset?.days || 30);
        let charts = {};
        let sortBy = 'views';
        let adminWs = null;
        let overviewInterval = null;

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function () {
            initializeNavigation();
            initializeCharts();
            initializeEventListeners();
            loadData();
            connectAdminWs();
            // --- æ–°å¢ï¼šè‡ªåŠ¨åˆ·æ–°é€»è¾‘ (æ¯ 2 ç§’åˆ·æ–°ä¸€æ¬¡) --- 
            console.log('Starting auto-refresh mechanism...'); 
            setInterval(async () => { 
                try { 
                    // 1. è·å–æœ€æ–°çš„å®æ—¶æ•°æ® 
                    const res = await fetch(`/analytics/api/realtime-overview?days=${currentDays}`, { credentials: 'include' }); 
                    if (res.ok) { 
                        const json = await res.json(); 
                        // 2. æ›´æ–°ç•Œé¢ä¸Šçš„æ•°å­— 
                        if (json.data) { 
                            updateRealtimeOverview(json.data); 
                            // åœ¨æ§åˆ¶å°æ‰“å°ä¸€ä¸‹ï¼Œè®©ä½ çŸ¥é“å®ƒåœ¨å·¥ä½œ 
                            console.log('ğŸ”„ Data auto-refreshed:', new Date().toLocaleTimeString()); 
                            
                            // 3. å¯é€‰ï¼šç»™æ€»æ”¶å…¥åŠ ä¸ªé—ªçƒç‰¹æ•ˆï¼Œæç¤ºç”¨æˆ·æ•°æ®å˜äº† 
                            const revenueEl = document.getElementById('total-revenue'); 
                            if (revenueEl) { 
                                revenueEl.style.color = '#4ade80'; // å˜ç»¿ä¸€ä¸‹ 
                                setTimeout(() => { revenueEl.style.color = ''; }, 500); 
                            } 
                        } 
                    } 
                } catch (err) { 
                    console.error('Auto-refresh failed:', err); 
                } 
            }, 2000); // 2000æ¯«ç§’ = 2ç§’ 
            // -------------------------------------------
            initializeCustomerService();
            if (document.getElementById('admin-cs-session')) { document.getElementById('admin-cs-session').textContent = window.CustomerService.sessionId(); }
        });

        // åˆå§‹åŒ–å¯¼èˆª
        function initializeNavigation() {
            const navLinks = document.querySelectorAll('.nav-link');
            const sections = document.querySelectorAll('.section');
            const dayButtons = document.querySelectorAll('[data-days]');
            const mainContainer = document.querySelector('.col-md-10 > .container-fluid.py-4');
            const dayGroup = document.getElementById('day-range-group');
            const hideSections = new Set(['server-monitor','error-logs','customer-service']);

            navLinks.forEach(link => {
                link.addEventListener('click', function (e) {
                    e.preventDefault();
                    const targetSection = this.getAttribute('data-section');

                    // æ›´æ–°å¯¼èˆªçŠ¶æ€
                    navLinks.forEach(l => l.classList.remove('active'));
                    this.classList.add('active');

                    // æ˜¾ç¤ºå¯¹åº”éƒ¨åˆ†
                    sections.forEach(section => {
                        section.style.display = section.id === targetSection ? 'block' : 'none';
                    });
                    if (mainContainer) mainContainer.style.display = 'block';
                    if (dayGroup) dayGroup.style.display = hideSections.has(targetSection) ? 'none' : 'inline-flex';
                });
            });

            dayButtons.forEach(button => {
                button.addEventListener('click', function () {
                    dayButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentDays = parseInt(this.getAttribute('data-days'));
                    loadData();
                });
            });

            const active = document.querySelector('.nav-link.active');
            if (active) {
                const targetSection = active.getAttribute('data-section');
                sections.forEach(section => { section.style.display = section.id === targetSection ? 'block' : 'none'; });
                if (mainContainer) mainContainer.style.display = 'block';
                if (dayGroup) dayGroup.style.display = hideSections.has(targetSection) ? 'none' : 'inline-flex';
            }
        }

        function initializeCustomerService() {
            const statusEl = document.getElementById('admin-cs-status');
            const chatEl = document.getElementById('admin-cs-chat');
            const inputEl = document.getElementById('admin-cs-input');
            const sendBtn = document.getElementById('admin-cs-send');
            const toastEl = document.getElementById('admin-cs-toast');
            if (!chatEl || !inputEl || !sendBtn) return;
            function fmtTime() { return new Date().toLocaleTimeString('zh-CN', { hour12: false, hour: '2-digit', minute: '2-digit' }); }
            function showToast(text) { toastEl.textContent = text; toastEl.classList.add('show'); setTimeout(() => { toastEl.classList.remove('show'); }, 2000); }
            function addMsg(text, who) {
                const row = document.createElement('div');
                row.className = 'cs-msg-row ' + (who === 'me' ? 'me' : 'srv');
                const avatar = document.createElement('div');
                avatar.className = 'cs-avatar ' + (who === 'me' ? 'me' : 'srv');
                avatar.textContent = who === 'me' ? 'Me' : 'Client';
                const bubble = document.createElement('div');
                bubble.className = 'cs-bubble ' + (who === 'me' ? 'me' : 'srv');
                bubble.innerHTML = '<div>' + text + '</div><div class="cs-time">' + fmtTime() + '</div>';
                if (who === 'me') { row.appendChild(bubble); row.appendChild(avatar); } else { row.appendChild(avatar); row.appendChild(bubble); }
                chatEl.appendChild(row);
                chatEl.scrollTop = chatEl.scrollHeight;
            }
            function doSend() {
                const text = (inputEl.value || '').trim();
                if (!text) return;
                addMsg(text, 'me');
                inputEl.value = '';
                window.CustomerService.sendQuestion(text);
            }
            document.addEventListener('cs:status', function (ev) {
                const d = ev.detail || {};
                if (statusEl) { statusEl.classList.toggle('offline', !d.connected); statusEl.innerHTML = (d.connected ? '<span class="dot"></span>Connected' : '<span class="dot"></span>Disconnected, retrying...'); }
                if (sendBtn) sendBtn.disabled = false;
            });
            document.addEventListener('cs:message', function (ev) {
                const msg = ev.detail || {};
                if (msg.type === 'reply') { addMsg(msg.message || 'Support Reply', 'srv'); }
                if (msg.type === 'ack') { showToast('Received, we will reply shortly'); }
            });
            sendBtn.addEventListener('click', doSend);
            inputEl.addEventListener('keydown', function (e) { if (e.key === 'Enter') { e.preventDefault(); doSend(); } });
            try { window.CustomerService.connect(); } catch (_) { }
        }

        function connectAdminWs() {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            adminWs = new WebSocket(`${proto}://${location.host}/admin/ws`);
            adminWs.onmessage = function (ev) {
                let msg; try { msg = JSON.parse(ev.data); } catch (_) { msg = { type: 'raw', data: ev.data }; }
                console.log('WS message received:', msg);
                if (msg.type === 'metrics') updateMetrics(msg.metrics);
                if (msg.type === 'clients') updateClients(msg.clients);
                if (msg.type === 'log') { appendLog(msg.log); if (msg.log && msg.log.level === 'error') appendErrorLog(msg.log.message || 'ERROR'); }
                if (msg.type === 'server_log') appendServerLog(msg.data || msg);
                if (msg.type === 'error_log') appendErrorLog(msg.data);
                if (msg.type === 'app_error') appendErrorLog(msg.data);
                if (msg.type === 'log_init' && Array.isArray(msg.logs)) { msg.logs.forEach(appendLog); }
            };
        }

        function gb(n) { return (n / 1024 / 1024 / 1024).toFixed(2); }
        function currentNumber(el) { const m = String(el?.textContent || '').match(/[\d.]+/); return m ? parseFloat(m[0]) : 0; }
        function setDisplayText(el, value) { const id = el.id || ''; if (id === 'total-revenue') { el.textContent = 'Â¥' + Number(value).toFixed(2); } else if (id === 'avg-order-value') { el.textContent = Number(value).toFixed(2); } else { el.textContent = Math.round(Number(value)); } }
        function animateValue(id, start, end, duration) { const el = document.getElementById(id); if (!el) return; if (start === undefined || start === null) start = currentNumber(el); const s = Number(start) || 0; const e = Number(end) || 0; if (s === e) { setDisplayText(el, e); return; } const t0 = performance.now(); const run = (now) => { const p = Math.min((now - t0) / duration, 1); const val = s + (e - s) * p; setDisplayText(el, val); if (p < 1) requestAnimationFrame(run); }; requestAnimationFrame(run); }
        async function refreshRealtimeData() { try { const resp = await fetch(`/analytics/api/realtime-overview?days=${currentDays}`, { credentials: 'include' }); if (!resp.ok) throw new Error(`HTTP ${resp.status}`); const data = await resp.json(); updateRealtimeOverview(data.data); } catch (e) { console.error('Real-time overview refresh failed', e && e.message ? e.message : e); if (overviewInterval) { clearInterval(overviewInterval); overviewInterval = null; } } }
        function startAutoRefresh() { try { if (overviewInterval) clearInterval(overviewInterval); refreshRealtimeData(); overviewInterval = setInterval(async () => { try { const res = await fetch(`/analytics/api/realtime-overview?days=${currentDays}`, { credentials: 'include' }); if (res.ok) { const json = await res.json(); updateRealtimeOverview(json.data); } } catch (e) { console.error('Auto-refresh failed:', e); } }, 3000); window.addEventListener('beforeunload', function () { if (overviewInterval) { try { clearInterval(overviewInterval); } catch (_) { } overviewInterval = null; } }); } catch (_) { }
        }
        function updateMetrics(m) {
            const cpuEl = document.getElementById('cpu-usage');
            const freeEl = document.getElementById('mem-free');
            const totalEl = document.getElementById('mem-total');
            if (cpuEl) cpuEl.textContent = `${m.cpu}%`;
            if (freeEl) freeEl.textContent = gb(m.memory.free);
            if (totalEl) totalEl.textContent = gb(m.memory.total);
        }
        function updateClients(list) {
            const el = document.getElementById('client-list');
            if (!el) return;
            el.innerHTML = '';
            const count = Array.isArray(list) ? list.length : 0;
            const t = document.createElement('div');
            t.textContent = `Online Sessions: ${count}`;
            el.appendChild(t);
            if (count > 0) {
                const ul = document.createElement('ul');
                list.forEach(c => { const li = document.createElement('li'); li.textContent = c.sessionId; ul.appendChild(li); });
                el.appendChild(ul);
            }
        }
        function appendLog(log) {
            const term = document.getElementById('terminal-window');
            if (!term) return;
            const rawMsg = (log.message || '');
            const rawPath = (log.path || log.url || log.uri || log.route || '');
            if ((rawMsg && rawMsg.includes('@vite')) || (rawPath && rawPath.includes('@vite'))) return;
            const cursorId = 'terminal-cursor';
            let cursor = document.getElementById(cursorId);
            if (cursor && cursor.parentElement) { try { cursor.parentElement.removeChild(cursor); } catch (_) {} }
            const line = document.createElement('div');
            line.className = 'terminal-line';
            const method = String((log.method || log.httpMethod || log.m || '')).toUpperCase();
            const path = rawPath;
            const statusNum = parseInt((log.status || log.statusCode || ''), 10) || (function(){ const m=(log.message||'').match(/\b(\d{3})\b/); return m?parseInt(m[1],10):0; })();
            const msValRaw = (log.ms ?? log.responseTime ?? log.duration ?? (function(){ const m=(log.message||'').match(/([\d.]+)\s*ms/); return m?m[1]:''; })());
            const msVal = msValRaw ? Number(msValRaw) : '';
            const sizeVal = (log.length ?? log.contentLength ?? log.size ?? (function(){ const m=(log.message||'').match(/-\s*(\d+)/); return m?m[1]:''; })());
            const sMethod = document.createElement('span'); sMethod.className = 't-method'; sMethod.textContent = method?`[${method}]`:'';
            const sPath = document.createElement('span'); sPath.className = 't-path'; sPath.textContent = path?` ${path}`:'';
            const sStatus = document.createElement('span'); sStatus.className = 't-status ' + (statusNum>=500?'err':statusNum>=400?'warn':statusNum>=300?'redir':'ok'); sStatus.textContent = statusNum?` ${statusNum}`:'';
            const sTime = document.createElement('span'); sTime.className = 't-time'; sTime.textContent = msVal!==''?` ${msVal} ms`:'';
            const sSize = document.createElement('span'); sSize.className = 't-size'; sSize.textContent = sizeVal?` - ${sizeVal}`:'';
            if (!method && !path && !statusNum && msVal==='') { line.textContent = (log.message || JSON.stringify(log)); }
            else { line.appendChild(sMethod); line.appendChild(sPath); line.appendChild(sStatus); line.appendChild(sTime); line.appendChild(sSize); }
            term.appendChild(line);
            cursor = document.createElement('span'); cursor.id = cursorId; cursor.className = 'terminal-cursor';
            term.appendChild(cursor);
            term.scrollTop = term.scrollHeight;
        }

        function appendServerLog(data) {
            const term = document.getElementById('terminal-window');
            if (!term) return;
            const rawPath = data.url || data.path || '';
            if (rawPath.includes('@vite')) return;
            const cursorId = 'terminal-cursor';
            let cursor = document.getElementById(cursorId);
            if (cursor && cursor.parentElement) { try { cursor.parentElement.removeChild(cursor); } catch (_) {} }
            const line = document.createElement('div');
            line.className = 'log-line';
            const method = String((data.method||'')).toUpperCase();
            const path = rawPath;
            const statusNum = Number(data.status||0);
            const msVal = Number((data.time!==undefined?data.time:''));
            const sMethod = document.createElement('span'); sMethod.className = 't-method'; sMethod.textContent = method?`[${method}]`:'';
            const sPath = document.createElement('span'); sPath.className = 't-path'; sPath.textContent = path?` ${path}`:'';
            const sStatus = document.createElement('span'); sStatus.className = 't-status ' + (statusNum>=500?'err':statusNum>=400?'warn':statusNum>=300?'redir':'ok'); sStatus.textContent = statusNum?` ${statusNum}`:'';
            const sTime = document.createElement('span'); sTime.className = 't-time'; sTime.textContent = (msVal||msVal===0)?` ${msVal} ms`:'';
            line.appendChild(sMethod); line.appendChild(sPath); line.appendChild(sStatus); line.appendChild(sTime);
            term.appendChild(line);
            cursor = document.createElement('span'); cursor.id = cursorId; cursor.className = 'terminal-cursor';
            term.appendChild(cursor);
            term.scrollTop = term.scrollHeight;
            if (statusNum >= 400) {
                const msg = `[${method}] ${path} ${statusNum} ${msVal} ms`;
                appendErrorLog(msg);
            }
        }

        function appendErrorLog(message) {
            const list = document.getElementById('log-list');
            if (!list) return console.error('æ‰¾ä¸åˆ° log-list å®¹å™¨');
            const item = document.createElement('div');
            item.className = 'alert alert-danger d-flex align-items-center mb-2';
            item.style.padding = '8px 12px';
            item.innerHTML = `
                <i class="fas fa-times-circle me-2"></i>
                <div>
                    <small class="text-muted" style="display:block; font-size:0.8em">${new Date().toLocaleTimeString()}</small>
                    <span style="font-family:monospace; word-break:break-all;">${message}</span>
                </div>
            `;
            list.prepend(item);
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            // äº§å“æ’åºæŒ‰é’®
            document.getElementById('sort-by-views')?.addEventListener('click', () => {
                sortBy = 'views';
                loadProductData();
            });
            document.getElementById('sort-by-sales')?.addEventListener('click', () => {
                sortBy = 'sales';
                loadProductData();
            });
            document.getElementById('sort-by-revenue')?.addEventListener('click', () => {
                sortBy = 'revenue';
                loadProductData();
            });
        }

        // åˆå§‹åŒ–å›¾è¡¨
        function initializeCharts() {
            if (typeof Chart === 'undefined') {
                console.warn('Chart.js æœªåŠ è½½ï¼Œè·³è¿‡å›¾è¡¨åˆå§‹åŒ–');
                return;
            }
            // è¡Œä¸ºç±»å‹åˆ†å¸ƒé¥¼å›¾
            if (document.getElementById('behaviorChart')) {
                const behaviorCtx = document.getElementById('behaviorChart').getContext('2d');
                charts.behavior = new Chart(behaviorCtx, {
                    type: 'doughnut',
                    data: {
                        labels: [],
                        datasets: [{
                            data: [],
                            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });
            }

            // è½¬åŒ–æ¼æ–—å›¾
            if (document.getElementById('conversionChart')) {
                const funnelCtx = document.getElementById('conversionChart').getContext('2d');
                charts.funnel = new Chart(funnelCtx, {
                    type: 'bar',
                    data: {
                        labels: ['æµè§ˆ', 'åŠ è´­ç‰©è½¦', 'è´­ä¹°'],
                        datasets: [{
                            label: 'ç”¨æˆ·æ•°é‡',
                            data: [],
                            backgroundColor: ['#36A2EB', '#FFCE56', '#4BC0C0']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // æ”¶å…¥è¶‹åŠ¿å›¾
            if (document.getElementById('revenueChart')) {
                const revenueCtx = document.getElementById('revenueChart').getContext('2d');
                charts.revenue = new Chart(revenueCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [{
                            label: 'Revenue (Â¥)',
                            data: [],
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: false,
                                ticks: {
                                    callback: function(value) {
                                        if (value >= 1000) return (value/1000).toFixed(1) + 'k';
                                        return value;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // ç”¨æˆ·æ´»è·ƒåº¦æ—¶é—´åˆ†å¸ƒå›¾
            if (document.getElementById('hourlyActivityChart')) {
                const hourlyCtx = document.getElementById('hourlyActivityChart').getContext('2d');
                charts.hourlyActivity = new Chart(hourlyCtx, {
                    type: 'bar',
                    data: {
                        labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
                        datasets: [{
                            label: 'æ´»è·ƒç”¨æˆ·æ•°',
                            data: [],
                            backgroundColor: '#17a2b8'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // ç”¨æˆ·ç»†åˆ†å›¾
            if (document.getElementById('userSegmentChart')) {
                const segmentCtx = document.getElementById('userSegmentChart').getContext('2d');
                charts.userSegment = new Chart(segmentCtx, {
                    type: 'pie',
                    data: {
                        labels: ['æ–°ç”¨æˆ·', 'æ´»è·ƒç”¨æˆ·', 'æ²‰ç¡ç”¨æˆ·', 'æµå¤±ç”¨æˆ·'],
                        datasets: [{
                            data: [],
                            backgroundColor: ['#28a745', '#17a2b8', '#ffc107', '#dc3545']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });
            }

            // äº§å“ç±»åˆ«é”€å”®åˆ†å¸ƒå›¾
            if (document.getElementById('categoryChart')) {
                const categoryCtx = document.getElementById('categoryChart').getContext('2d');
                charts.category = new Chart(categoryCtx, {
                    type: 'doughnut',
                    data: {
                        labels: [],
                        datasets: [{
                            data: [],
                            backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom'
                            }
                        }
                    }
                });
            }

            // äº§å“è¯„åˆ†åˆ†å¸ƒå›¾
            if (document.getElementById('ratingChart')) {
                const ratingCtx = document.getElementById('ratingChart').getContext('2d');
                charts.rating = new Chart(ratingCtx, {
                    type: 'bar',
                    data: {
                        labels: ['1æ˜Ÿ', '2æ˜Ÿ', '3æ˜Ÿ', '4æ˜Ÿ', '5æ˜Ÿ'],
                        datasets: [{
                            label: 'äº§å“æ•°é‡',
                            data: [],
                            backgroundColor: ['#dc3545', '#fd7e14', '#ffc107', '#28a745', '#20c997']
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // äº§å“é”€å”®è¶‹åŠ¿å›¾
            if (document.getElementById('productTrendChart')) {
                const productTrendCtx = document.getElementById('productTrendChart').getContext('2d');
                charts.productTrend = new Chart(productTrendCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'æ—¥æœŸ'
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'é”€å”®é‡'
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            }
                        }
                    }
                });
            }

            // è¶‹åŠ¿å›¾
            if (document.getElementById('trendChart')) {
                const trendCtx = document.getElementById('trendChart').getContext('2d');
                charts.trend = new Chart(trendCtx, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            intersect: false,
                            mode: 'index'
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    usePointStyle: true,
                                    padding: 20,
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1,
                                cornerRadius: 6,
                                displayColors: true
                            }
                        },
                        scales: {
                            x: {
                                display: true,
                                title: {
                                    display: true,
                                    text: 'æ—¥æœŸ',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)',
                                    lineWidth: 1
                                },
                                ticks: {
                                    font: {
                                        size: 11
                                    },
                                    maxRotation: 45
                                }
                            },
                            y: {
                                display: true,
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'æ•°é‡',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)',
                                    lineWidth: 1
                                },
                                ticks: {
                                    font: {
                                        size: 11
                                    }
                                }
                            }
                        },
                        elements: {
                            line: {
                                tension: 0.4
                            },
                            point: {
                                radius: 4,
                                hoverRadius: 6,
                                borderWidth: 2
                            }
                        }
                    }
                });
            }
        }

        // åŠ è½½æ•°æ®
        async function loadData() {
            console.log('Loading data, days:', currentDays);

            try {
                // åŠ è½½å®æ—¶æ¦‚è§ˆæ•°æ®
                console.log('Loading real-time overview data...');
                const realtimeResponse = await fetch(`/analytics/api/realtime-overview?days=${currentDays}`, { credentials: 'include' });
                if (!realtimeResponse.ok) {
                    throw new Error(`Real-time overview API request failed: ${realtimeResponse.status} ${realtimeResponse.statusText}`);
                }
                const realtimeData = await realtimeResponse.json();
                console.log('Real-time overview data:', realtimeData);
                updateRealtimeOverview(realtimeData.data);
                console.log('âœ… Real-time overview data loaded');

                // åŠ è½½æ¦‚è§ˆæ•°æ®
                console.log('Loading overview data...');
                const overviewResponse = await fetch(`/analytics/api/overview?days=${currentDays}`, { credentials: 'include' });
                if (!overviewResponse.ok) {
                    throw new Error(`Overview API request failed: ${overviewResponse.status} ${overviewResponse.statusText}`);
                }
                const overviewData = await overviewResponse.json();
                console.log('Overview data:', overviewData);
                updateOverview(overviewData.data);
                console.log('âœ… Overview data loaded');

                // åŠ è½½é«˜çº§ç”¨æˆ·è¡Œä¸ºæ•°æ®
                console.log('Loading advanced user behavior data...');
                const advancedBehaviorResponse = await fetch(`/analytics/api/advanced-user-behavior?days=${currentDays}`, { credentials: 'include' });
                if (!advancedBehaviorResponse.ok) {
                    throw new Error(`Advanced user behavior API request failed: ${advancedBehaviorResponse.status} ${advancedBehaviorResponse.statusText}`);
                }
                const advancedBehaviorData = await advancedBehaviorResponse.json();
                console.log('Advanced user behavior data:', advancedBehaviorData);
                updateAdvancedBehaviorCharts(advancedBehaviorData.data);
                console.log('âœ… Advanced user behavior data loaded');

                // åŠ è½½ç”¨æˆ·è¡Œä¸ºæ•°æ®
                console.log('Loading user behavior data...');
                const behaviorResponse = await fetch(`/analytics/api/user-behavior?days=${currentDays}`, { credentials: 'include' });
                if (!behaviorResponse.ok) {
                    throw new Error(`User behavior API request failed: ${behaviorResponse.status} ${behaviorResponse.statusText}`);
                }
                const behaviorData = await behaviorResponse.json();
                console.log('User behavior data:', behaviorData);
                updateBehaviorCharts(behaviorData.data);
                console.log('âœ… User behavior data loaded');

                // åŠ è½½äº§å“æ€§èƒ½æ•°æ®
                console.log('Loading product performance data...');
                await loadProductData();
                console.log('âœ… Product performance data loaded');

                // åŠ è½½è¶‹åŠ¿æ•°æ®
                console.log('Loading trend data...');
                const trendResponse = await fetch(`/analytics/api/trends?days=${currentDays}`, { credentials: 'include' });
                if (!trendResponse.ok) {
                    throw new Error(`Trend API request failed: ${trendResponse.status} ${trendResponse.statusText}`);
                }
                const trendData = await trendResponse.json();
                console.log('Trend data:', trendData);
                updateTrendChart(trendData.data);
                console.log('âœ… Trend data loaded');

                console.log('ğŸ‰ All data loaded');

            } catch (error) {
                console.error('âŒ Failed to load data:', error);
                // æ˜¾ç¤ºé”™è¯¯æç¤º
                showErrorMessage('Failed to load data: ' + error.message);
            }
        }

        // åŠ è½½äº§å“æ•°æ®
        async function loadProductData() {
            try {
                console.log('Loading product performance data...');
                const productResponse = await fetch(`/analytics/api/product-performance?days=${currentDays}&sortBy=${sortBy}`, { credentials: 'include' });
                if (!productResponse.ok) {
                    throw new Error(`Product performance API request failed: ${productResponse.status} ${productResponse.statusText}`);
                }
                const productData = await productResponse.json();
                console.log('Product performance data:', productData);

                if (!productData.data || !Array.isArray(productData.data)) {
                    throw new Error('Invalid product performance data format');
                }

                updateProductTable(productData.data);
                updateProductCharts(productData.data);
                return true;
            } catch (error) {
                console.error('âŒ Failed to load product data:', error);
                showErrorMessage('Failed to load product data: ' + error.message);
                return false;
            }
        }

        // æ›´æ–°å®æ—¶æ¦‚è§ˆæ•°æ®
        function updateRealtimeOverview(data) {
            try {
                console.log('Updating real-time overview data:', data);
                if (data) {
                    // ä½¿ç”¨æ­£ç¡®çš„æ•°æ®ç»“æ„å­—æ®µ
                    const totalUsersEl = document.getElementById('total-users');
                    const dailyActiveUsersEl = document.getElementById('daily-active-users');
                    const totalOrdersEl = document.getElementById('total-orders');
                    const totalRevenueEl = document.getElementById('total-revenue');
                    const avgOrderValueEl = document.getElementById('avg-order-value');
                    const totalViewsEl = document.getElementById('total-views');

                    if (totalUsersEl) animateValue('total-users', currentNumber(totalUsersEl), Number(data.users?.total || 0), 1000);
                    if (dailyActiveUsersEl) animateValue('daily-active-users', currentNumber(dailyActiveUsersEl), Number(data.users?.daily_active || 0), 1000);
                    if (totalOrdersEl) animateValue('total-orders', currentNumber(totalOrdersEl), Number(data.orders?.total || 0), 1000);
                    if (totalRevenueEl) animateValue('total-revenue', currentNumber(totalRevenueEl), Number(data.orders?.total_revenue || 0), 1000);
                    if (avgOrderValueEl) animateValue('avg-order-value', currentNumber(avgOrderValueEl), Number(data.orders?.avg_value || 0), 1000);
                    if (totalViewsEl) totalViewsEl.textContent = data.products?.total_views || 0;
                    const conversionEl = document.getElementById('conversion-rate');
                    if (conversionEl && data.conversion_rates) {
                        conversionEl.textContent = (data.conversion_rates.viewToPurchase || 0) + '%';
                    }

                    // å¦‚æœæœ‰ä¼šè¯æŒ‡æ ‡æ•°æ®
                    if (data.session_metrics) {
                        const avgSessionDurationEl = document.getElementById('avg-session-duration');
                        const bounceRateEl = document.getElementById('bounce-rate');
                        if (avgSessionDurationEl) avgSessionDurationEl.textContent = (data.session_metrics?.avg_duration || 0).toFixed(1);
                        if (bounceRateEl) bounceRateEl.textContent = `${(data.session_metrics?.bounce_rate || 0).toFixed(1)}%`;
                    }

                    // æ›´æ–°æ”¶å…¥è¶‹åŠ¿å›¾
                    if (charts.revenue && data.revenue_trend && Array.isArray(data.revenue_trend)) {
                        try {
                            charts.revenue.data.labels = data.revenue_trend.map(item => item.date);
                            charts.revenue.data.datasets[0].data = data.revenue_trend.map(item => item.daily_revenue || item.revenue || item.value || 0);
                            charts.revenue.update();
                            console.log('âœ… Revenue trend chart updated, points:', data.revenue_trend.length);
                        } catch (revenueError) {
                            console.error('âŒ Failed to update revenue trend chart:', revenueError);
                        }
                    } else {
                        console.warn('âš ï¸ Revenue trend chart data missing or invalid:', data.revenue_trend);
                    }
                    console.log('âœ… Real-time overview data updated');
                } else {
                    console.warn('âš ï¸ Real-time overview data is empty');
                }
            } catch (error) {
                console.error('âŒ Failed to update real-time overview data:', error);
                showErrorMessage('Failed to update real-time overview data: ' + error.message);
            }
        }

        // æ›´æ–°æ¦‚è§ˆæ•°æ®
        function updateOverview(data) {
            if (data && data.users) {
                // è¿™äº›æ•°æ®å¯èƒ½å·²ç»åœ¨å®æ—¶æ¦‚è§ˆä¸­æ›´æ–°äº†
            }
        }

        // æ›´æ–°é«˜çº§ç”¨æˆ·è¡Œä¸ºæ•°æ®
        function updateAdvancedBehaviorCharts(data) {
            try {
                console.log('Updating advanced user behavior data:', data);
                if (data) {
                    // æ›´æ–°ä¼šè¯æŒ‡æ ‡
                    if (data.session_metrics) {
                        const avgSessionDurationEl = document.getElementById('avg-session-duration');
                        const bounceRateEl = document.getElementById('bounce-rate');
                        const avgActionsPerSessionEl = document.getElementById('avg-actions-per-session');

                        if (avgSessionDurationEl) avgSessionDurationEl.textContent = (data.session_metrics.avg_duration || 0) + ' min';
                        if (bounceRateEl) bounceRateEl.textContent = `${(data.session_metrics.bounce_rate || 0)}%`;
                        if (avgActionsPerSessionEl) avgActionsPerSessionEl.textContent = (data.session_metrics.avg_actions_per_session || 0).toFixed(1);
                        console.log('âœ… Session metrics updated');
                    } else {
                        console.warn('âš ï¸ Session metrics data missing');
                    }

                    // æ›´æ–°ç”¨æˆ·æ´»è·ƒåº¦æ—¶é—´åˆ†å¸ƒå›¾
                    if (charts.hourlyActivity && data.hourly_activity) {
                        try {
                            const hourlyData = new Array(24).fill(0);
                            data.hourly_activity.forEach(item => {
                                const hour = parseInt(item.hour);
                                if (!isNaN(hour) && hour >= 0 && hour < 24) {
                                    hourlyData[hour] = item.actions || 0;
                                }
                            });
                            charts.hourlyActivity.data.datasets[0].data = hourlyData;
                            charts.hourlyActivity.update();
                            console.log('âœ… Hourly activity chart updated');
                        } catch (chartError) {
                            console.error('âŒ Failed to update hourly activity chart:', chartError);
                        }
                    } else {
                        console.warn('âš ï¸ Hourly activity data or chart missing');
                    }

                    // æ›´æ–°è®¾å¤‡åˆ†å¸ƒå›¾
                    if (charts.userSegment && data.device_distribution) {
                        try {
                            const deviceLabels = data.device_distribution.map(item => item.device_type || 'Unknown');
                            const deviceData = data.device_distribution.map(item => item.users || 0);
                            charts.userSegment.data.labels = deviceLabels;
                            charts.userSegment.data.datasets[0].data = deviceData;
                            charts.userSegment.update();
                            console.log('âœ… Device distribution chart updated');
                        } catch (chartError) {
                            console.error('âŒ Failed to update device distribution chart:', chartError);
                        }
                    } else {
                        console.warn('âš ï¸ Device distribution data or chart missing');
                    }

                    // æ›´æ–°ç”¨æˆ·è·¯å¾„åˆ—è¡¨
                    if (data.user_paths) {
                        try {
                            updateUserPaths(data.user_paths);
                            console.log('âœ… User path list updated');
                        } catch (pathError) {
                            console.error('âŒ Failed to update user path list:', pathError);
                        }
                    } else {
                        console.warn('âš ï¸ User path data missing');
                    }

                    console.log('âœ… Advanced user behavior data updated');
                } else {
                    console.warn('âš ï¸ Advanced user behavior data is empty');
                }
            } catch (error) {
                console.error('âŒ Failed to update advanced user behavior data:', error);
                showErrorMessage('Failed to update advanced user behavior data: ' + error.message);
            }
        }

        // æ›´æ–°ç”¨æˆ·è·¯å¾„
        function updateUserPaths(paths) {
            const pathsList = document.getElementById('user-paths-list');
            if (pathsList) {
                pathsList.innerHTML = '';

                // å¤„ç†ç”¨æˆ·è·¯å¾„æ•°æ®ï¼ŒæŒ‰ç”¨æˆ·åˆ†ç»„æ˜¾ç¤ºæœ€è¿‘çš„è¡Œä¸ºåºåˆ—
                const userGroups = {};
                paths.forEach(path => {
                    if (!userGroups[path.user_id]) {
                        userGroups[path.user_id] = [];
                    }
                    userGroups[path.user_id].push(path);
                });

                // æ˜¾ç¤ºå‰5ä¸ªç”¨æˆ·çš„è¡Œä¸ºè·¯å¾„
                Object.keys(userGroups).slice(0, 5).forEach((userId, index) => {
                    const userPaths = userGroups[userId].slice(0, 5); // æ¯ä¸ªç”¨æˆ·æ˜¾ç¤ºæœ€å¤š5ä¸ªè¡Œä¸º
                    const pathElement = document.createElement('div');
                    pathElement.className = 'mb-2 p-2 bg-dark rounded';

                    const pathSequence = userPaths.map(p => p.action_type).join(' â†’ ');
                    pathElement.innerHTML = `
                        <small class="text-muted">User #${userId}</small>
                        <div class="text-light">${pathSequence}</div>
                        <small class="text-info">${userPaths.length} actions</small>
                    `;
                    pathsList.appendChild(pathElement);
                });
            }
        }

        // æ›´æ–°è¡Œä¸ºå›¾è¡¨
        function updateBehaviorCharts(data) {
            try {
                console.log('Updating user behavior charts and metrics...', data);

                // æ›´æ–°ç”¨æˆ·è¡Œä¸ºæ¦‚è§ˆæŒ‡æ ‡
                try {
                    const totalClicksEl = document.getElementById('total-clicks');
                    const cartAddsEl = document.getElementById('cart-additions');
                    const wishlistAddsEl = document.getElementById('wishlist-additions');
                    const sharesEl = document.getElementById('shares');

                    // ä»actionStatsä¸­æå–å„ç§è¡Œä¸ºçš„ç»Ÿè®¡æ•°æ®
                    let totalClicks = 0;
                    let cartAdditions = 0;
                    let wishlistAdditions = 0;
                    let shares = 0;

                    if (data.actionStats && Array.isArray(data.actionStats)) {
                        data.actionStats.forEach(stat => {
                            const actionType = stat.action_type;
                            const count = stat.count || 0;

                            // ç»Ÿè®¡ç‚¹å‡»æ•°ï¼ˆåŒ…æ‹¬æµè§ˆã€äº§å“æŸ¥çœ‹ç­‰ï¼‰
                            if (actionType === 'view' || actionType === 'product_view' || actionType === 'click') {
                                totalClicks += count;
                            }
                            // ç»Ÿè®¡åŠ è´­æ¬¡æ•°
                            else if (actionType === 'add_to_cart') {
                                cartAdditions += count;
                            }
                            // ç»Ÿè®¡æ”¶è—æ¬¡æ•°
                            else if (actionType === 'wishlist' || actionType === 'favorite' || actionType === 'add_to_wishlist') {
                                wishlistAdditions += count;
                            }
                            // ç»Ÿè®¡åˆ†äº«æ¬¡æ•°
                            else if (actionType === 'share') {
                                shares += count;
                            }
                        });
                    }

                    // å¦‚æœæ²¡æœ‰ä»actionStatsè·å–åˆ°æ•°æ®ï¼Œå°è¯•ä»rawConversionDataè·å–
                    if (totalClicks === 0 && data.rawConversionData) {
                        totalClicks = data.rawConversionData.views || 0;
                        cartAdditions = data.rawConversionData.cart_adds || 0;
                    }

                    // æ›´æ–°DOMå…ƒç´ 
                    if (totalClicksEl) totalClicksEl.textContent = totalClicks;
                    if (cartAddsEl) cartAddsEl.textContent = cartAdditions;
                    if (wishlistAddsEl) wishlistAddsEl.textContent = wishlistAdditions;
                    if (sharesEl) sharesEl.textContent = shares;

                    console.log('âœ… User behavior overview metrics updated:', {
                        totalClicks,
                        cartAdditions,
                        wishlistAdditions,
                        shares
                    });
                } catch (metricsError) {
                    console.error('âŒ Failed to update user behavior overview metrics:', metricsError);
                }

                // æ›´æ–°è¡Œä¸ºåˆ†å¸ƒå›¾è¡¨
                if (data.actionStats && charts.behavior) {
                    try {
                        charts.behavior.data.labels = data.actionStats.map(item => item.action_type);
                        charts.behavior.data.datasets[0].data = data.actionStats.map(item => item.count);
                        charts.behavior.update();
                        console.log('âœ… Behavior distribution chart updated');
                    } catch (chartError) {
                        console.error('âŒ Failed to update behavior distribution chart:', chartError);
                    }
                }

                // æ›´æ–°è½¬åŒ–æ¼æ–—å›¾è¡¨
                if (data.rawConversionData && charts.funnel) {
                    try {
                        charts.funnel.data.datasets[0].data = [
                            data.rawConversionData.views,
                            data.rawConversionData.cart_adds,
                            data.rawConversionData.purchases
                        ];
                        charts.funnel.update();
                        console.log('âœ… Conversion funnel chart updated');
                    } catch (funnelError) {
                        console.error('âŒ Failed to update conversion funnel chart:', funnelError);
                    }
                }

                console.log('âœ… User behavior charts and metrics updated');
            } catch (error) {
                console.error('âŒ Failed to update user behavior charts:', error);
                showErrorMessage('Failed to update user behavior charts: ' + error.message);
            }
        }

        // æ›´æ–°äº§å“è¡¨æ ¼
        function updateProductTable(data) {
            try {
                console.log('Updating product table, data length:', data ? data.length : 0);
                const tbody = document.querySelector('#productTable tbody');
                if (!tbody) {
                    console.error('âŒ Product table tbody not found');
                    return;
                }

                tbody.innerHTML = '';

                if (!data || !Array.isArray(data)) {
                    console.warn('âš ï¸ Product data is empty or invalid');
                    const row = tbody.insertRow();
                    row.innerHTML = '<td colspan="10" class="text-center text-muted">No product data available</td>';
                    return;
                }

                data.forEach((product, index) => {
                    try {
                        // ä»äº§å“åç§°æ¨æ–­ç±»åˆ«
                        let category = 'Uncategorized';
                        const name = product.name || '';
                        if (name.includes('æ‰‹æœº')) category = 'Phone';
                        else if (name.includes('ç”µè„‘') || name.includes('ç¬”è®°æœ¬')) category = 'Computer';
                        else if (name.includes('è€³æœº')) category = 'Headphones';
                        else if (name.includes('å……ç”µå™¨')) category = 'Charger';
                        else if (name.includes('éŸ³å“')) category = 'Speaker';
                        else if (name.includes('å¹³æ¿')) category = 'Tablet';
                        else if (name.includes('æ•°æ®çº¿')) category = 'Data Cable';
                        else if (name.includes('é”®ç›˜')) category = 'Keyboard';
                        else if (name.includes('é¼ æ ‡')) category = 'Mouse';
                        else if (name.includes('æ˜¾ç¤ºå™¨')) category = 'Monitor';

                        const row = tbody.insertRow();
                        row.innerHTML = `
                            <td>${index + 1}</td>
                            <td>${product.name || 'Unknown Product'}</td>
                            <td>${product.category || category}</td>
                            <td>${product.views || 0}</td>
                            <td>${product.cart_adds || 0}</td>
                            <td>${product.purchases || 0}</td>
                            <td>${parseFloat(product.conversion_rate || 0).toFixed(2)}%</td>
                            <td>Â¥${parseFloat(product.revenue || 0).toFixed(2)}</td>
                            <td>${parseFloat(product.avg_preference_score || 0).toFixed(1)}</td>
                            <td>${product.stock || 0}</td>
                        `;
                    } catch (rowError) {
                        console.error(`âŒ Failed to create product table row (index ${index}):`, rowError, product);
                    }
                });

                console.log(`âœ… Product table updated, ${data.length} rows`);
            } catch (error) {
                console.error('âŒ Failed to update product table:', error);
                showErrorMessage('Failed to update product table: ' + error.message);
            }
        }

        // æ›´æ–°äº§å“å›¾è¡¨
        function updateProductCharts(data) {
            try {
                console.log('Updating product charts, data length:', data ? data.length : 0);

                if (!data || !Array.isArray(data)) {
                    console.warn('âš ï¸ Product chart data is empty or invalid');
                    return;
                }

                // æ›´æ–°äº§å“æ¦‚è§ˆæŒ‡æ ‡
                try {
                    const totalProductsEl = document.getElementById('total-products');
                    const hotProductsEl = document.getElementById('hot-products');
                    const trendingProductsEl = document.getElementById('trending-products');
                    const lowStockProductsEl = document.getElementById('low-stock-products');

                    if (totalProductsEl) totalProductsEl.textContent = data.length || 0;
                    if (hotProductsEl) hotProductsEl.textContent = data.filter(p => (p.views || 0) > 100).length || 0;

                    // ä½¿ç”¨composite_scoreä½œä¸ºè¶‹åŠ¿æŒ‡æ ‡çš„æ›¿ä»£
                    const trendingCount = data.filter(p => (p.composite_score || 0) > 50).length || 0;
                    if (trendingProductsEl) trendingProductsEl.textContent = trendingCount;

                    if (lowStockProductsEl) lowStockProductsEl.textContent = data.filter(p => (p.stock || 0) < 10).length || 0;

                    console.log('âœ… Product overview metrics updated');
                } catch (metricsError) {
                    console.error('âŒ Failed to update product overview metrics:', metricsError);
                }

                // æ›´æ–°äº§å“ç±»åˆ«åˆ†å¸ƒå›¾
                if (charts.category) {
                    try {
                        const categoryData = {};
                        data.forEach(product => {
                            // ä»äº§å“åç§°æ¨æ–­ç±»åˆ«
                            let category = 'Uncategorized';
                            const name = product.name || '';
                            if (name.includes('æ‰‹æœº')) category = 'Phone';
                            else if (name.includes('ç”µè„‘') || name.includes('ç¬”è®°æœ¬')) category = 'Computer';
                            else if (name.includes('è€³æœº')) category = 'Headphones';
                            else if (name.includes('å……ç”µå™¨')) category = 'Charger';
                            else if (name.includes('éŸ³å“')) category = 'Speaker';
                            else if (name.includes('å¹³æ¿')) category = 'Tablet';
                            else if (name.includes('æ•°æ®çº¿')) category = 'Data Cable';
                            else if (name.includes('é”®ç›˜')) category = 'Keyboard';
                            else if (name.includes('é¼ æ ‡')) category = 'Mouse';
                            else if (name.includes('æ˜¾ç¤ºå™¨')) category = 'Monitor';

                            const finalCategory = product.category || category;
                            categoryData[finalCategory] = (categoryData[finalCategory] || 0) + (product.revenue || 0);
                        });

                        charts.category.data.labels = Object.keys(categoryData);
                        charts.category.data.datasets[0].data = Object.values(categoryData);
                        charts.category.update();
                        console.log('âœ… Product category distribution chart updated');
                    } catch (categoryError) {
                        console.error('âŒ Failed to update product category distribution chart:', categoryError);
                    }
                } else {
                    console.warn('âš ï¸ Product category distribution chart object missing');
                }

                // æ›´æ–°äº§å“è¯„åˆ†åˆ†å¸ƒå›¾ - ä½¿ç”¨avg_preference_scoreæ›¿ä»£rating
                if (charts.rating) {
                    try {
                        const ratingData = [0, 0, 0, 0, 0];
                        data.forEach(product => {
                            // å°†avg_preference_scoreè½¬æ¢ä¸º1-5çš„è¯„åˆ†
                            const score = product.avg_preference_score || 0;
                            const rating = Math.min(Math.max(Math.floor(score * 5), 1), 5);
                            if (rating >= 1 && rating <= 5) {
                                ratingData[rating - 1]++;
                            }
                        });

                        charts.rating.data.datasets[0].data = ratingData;
                        charts.rating.update();
                        console.log('âœ… Product rating distribution chart updated');
                    } catch (ratingError) {
                        console.error('âŒ Failed to update product rating distribution chart:', ratingError);
                    }
                } else {
                    console.warn('âš ï¸ Product rating distribution chart object missing');
                }

                console.log('âœ… Product charts updated');
            } catch (error) {
                console.error('âŒ Failed to update product charts:', error);
                showErrorMessage('Failed to update product charts: ' + error.message);
            }
        }

        // æ›´æ–°è¶‹åŠ¿å›¾è¡¨
        function updateTrendChart(data) {
            try {
                console.log('Updating trend chart, data:', data);

                // æ›´æ–°è¶‹åŠ¿åˆ†æé¡µé¢çš„å›¾è¡¨
                if (charts.trend) {
                    let labels = [];
                    let datasets = [];

                    // å¤„ç†æ´»è·ƒç”¨æˆ·æ•°æ®
                    if (data.active_users && Array.isArray(data.active_users) && data.active_users.length > 0) {
                        labels = data.active_users.map(item => {
                            // æ ¼å¼åŒ–æ—¥æœŸæ˜¾ç¤º
                            const date = new Date(item.date);
                            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        });

                        datasets.push({
                            label: 'Active Users',
                            data: data.active_users.map(item => item.value || 0),
                            borderColor: '#36A2EB',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#36A2EB',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        });

                        console.log('Active user data points:', data.active_users.map(item => item.value || 0));
                    }

                    // å¤„ç†è®¢å•æ•°æ®
                    if (data.orders && Array.isArray(data.orders) && data.orders.length > 0) {
                        // å¦‚æœè¿˜æ²¡æœ‰æ ‡ç­¾ï¼Œä½¿ç”¨è®¢å•æ•°æ®çš„æ—¥æœŸ
                        if (labels.length === 0) {
                            labels = data.orders.map(item => {
                                const date = new Date(item.date);
                                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            });
                        }

                        datasets.push({
                            label: 'Orders',
                            data: data.orders.map(item => item.value || 0),
                            borderColor: '#FF6384',
                            backgroundColor: 'rgba(255, 99, 132, 0.1)',
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#FF6384',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        });

                        console.log('Order data points:', data.orders.map(item => item.value || 0));
                    }

                    // å¤„ç†æ”¶å…¥æ•°æ®
                    if (data.revenue && Array.isArray(data.revenue) && data.revenue.length > 0) {
                        // å¦‚æœè¿˜æ²¡æœ‰æ ‡ç­¾ï¼Œä½¿ç”¨æ”¶å…¥æ•°æ®çš„æ—¥æœŸ
                        if (labels.length === 0) {
                            labels = data.revenue.map(item => {
                                const date = new Date(item.date);
                                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            });
                        }

                        datasets.push({
                            label: 'Revenue (Â¥)',
                            data: data.revenue.map(item => item.value || 0),
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            fill: false,
                            tension: 0.4,
                            pointBackgroundColor: '#28a745',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            yAxisID: 'y1'
                        });

                        // æ·»åŠ ç¬¬äºŒä¸ªYè½´ç”¨äºæ”¶å…¥
                        if (!charts.trend.options.scales.y1) {
                            charts.trend.options.scales.y1 = {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Revenue (Â¥)',
                                    font: {
                                        size: 12,
                                        weight: 'bold'
                                    }
                                },
                                grid: {
                                    drawOnChartArea: false,
                                    color: 'rgba(40, 167, 69, 0.1)'
                                },
                                ticks: {
                                    font: {
                                        size: 11
                                    }
                                }
                            };
                        }

                        console.log('Revenue data points:', data.revenue.map(item => item.value || 0));
                    }

                    // å¦‚æœæ²¡æœ‰ä»»ä½•æ•°æ®ï¼Œåˆ›å»ºç¤ºä¾‹æ•°æ®
                    if (labels.length === 0 || datasets.length === 0) {
                        console.log('No trend data, creating sample data');
                        const today = new Date();
                        labels = [];
                        const sampleData = [];

                        for (let i = 6; i >= 0; i--) {
                            const date = new Date(today);
                            date.setDate(date.getDate() - i);
                            labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
                            sampleData.push(Math.floor(Math.random() * 100) + 50);
                        }

                        datasets = [{
                            label: 'Active Users',
                            data: sampleData,
                            borderColor: '#36A2EB',
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            fill: true,
                            tension: 0.4,
                            pointBackgroundColor: '#36A2EB',
                            pointBorderColor: '#ffffff',
                            pointBorderWidth: 2,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        }];
                    }

                    // æ›´æ–°å›¾è¡¨æ•°æ®
                    charts.trend.data.labels = labels;
                    charts.trend.data.datasets = datasets;
                    charts.trend.update('active');

                    console.log('âœ… Trend chart updated, labels:', labels.length, 'datasets:', datasets.length);
                }

                // æ›´æ–°äº§å“æ€§èƒ½é¡µé¢çš„äº§å“é”€å”®è¶‹åŠ¿å›¾è¡¨
                if (charts.productTrend) {
                    try {
                        console.log('Updating product sales trend chart, raw data:', data);

                        // ä½¿ç”¨è¶‹åŠ¿æ•°æ®æ›´æ–°äº§å“é”€å”®è¶‹åŠ¿å›¾
                        const labels = [];
                        const salesData = [];
                        const revenueData = [];

                        // å¦‚æœæœ‰è®¢å•æ•°æ®ï¼Œä½¿ç”¨è®¢å•æ•°æ®ä½œä¸ºé”€å”®è¶‹åŠ¿
                        if (data.orders && Array.isArray(data.orders)) {
                            console.log('Processing order data:', data.orders);
                            data.orders.forEach(item => {
                                labels.push(item.date);
                                salesData.push(item.value || 0);
                            });
                        }

                        // å¦‚æœæœ‰æ”¶å…¥æ•°æ®ï¼Œæ·»åŠ æ”¶å…¥è¶‹åŠ¿
                        if (data.revenue && Array.isArray(data.revenue)) {
                            console.log('Processing revenue data:', data.revenue);
                            data.revenue.forEach((item, index) => {
                                if (index < labels.length) {
                                    revenueData.push(item.value || 0);
                                } else if (labels.length === 0) {
                                    labels.push(item.date);
                                    revenueData.push(item.value || 0);
                                }
                            });
                        }

                        // å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œåˆ›å»ºç¤ºä¾‹æ•°æ®ä»¥ç¡®ä¿å›¾è¡¨æ˜¾ç¤º
                        if (labels.length === 0) {
                            console.log('No trend data, creating sample data');
                            const today = new Date();
                            for (let i = 6; i >= 0; i--) {
                                const date = new Date(today);
                                date.setDate(date.getDate() - i);
                                labels.push(date.toISOString().split('T')[0]);
                                salesData.push(Math.floor(Math.random() * 50) + 10);
                                revenueData.push(Math.floor(Math.random() * 5000) + 1000);
                            }
                        }

                        console.log('Chart labels:', labels);
                        console.log('Sales data:', salesData);
                        console.log('Revenue data:', revenueData);

                        // æ›´æ–°å›¾è¡¨æ•°æ®
                        charts.productTrend.data.labels = labels;
                        charts.productTrend.data.datasets = [];

                        if (salesData.length > 0) {
                            charts.productTrend.data.datasets.push({
                                label: 'Sales Volume',
                                data: salesData,
                                borderColor: '#28a745',
                                backgroundColor: 'rgba(40, 167, 69, 0.1)',
                                fill: false,
                                tension: 0.4,
                                pointBackgroundColor: '#28a745',
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2,
                                pointRadius: 4
                            });
                        }

                        if (revenueData.length > 0) {
                            charts.productTrend.data.datasets.push({
                                label: 'Revenue Trend (Â¥)',
                                data: revenueData,
                                borderColor: '#007bff',
                                backgroundColor: 'rgba(0, 123, 255, 0.1)',
                                fill: false,
                                tension: 0.4,
                                pointBackgroundColor: '#007bff',
                                pointBorderColor: '#ffffff',
                                pointBorderWidth: 2,
                                pointRadius: 4,
                                yAxisID: 'y1'
                            });

                            // æ·»åŠ ç¬¬äºŒä¸ªYè½´ç”¨äºæ”¶å…¥
                            charts.productTrend.options.scales.y1 = {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Revenue (Â¥)'
                                },
                                grid: {
                                    drawOnChartArea: false,
                                    color: 'rgba(0, 123, 255, 0.1)'
                                }
                            };
                        }

                        charts.productTrend.update('active');
                        console.log('âœ… Product sales trend chart updated, datasets:', charts.productTrend.data.datasets.length);
                    } catch (productTrendError) {
                        console.error('âŒ Failed to update product sales trend chart:', productTrendError);
                    }
                }
            } catch (error) {
                console.error('âŒ Failed to update trend chart:', error);
            }
        }

        // æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
        function showErrorMessage(message) {
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨é”™è¯¯æç¤ºå…ƒç´ 
            let errorElement = document.getElementById('error-message');

            // å¦‚æœä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„
            if (!errorElement) {
                errorElement = document.createElement('div');
                errorElement.id = 'error-message';
                errorElement.className = 'alert alert-danger alert-dismissible fade show';
                errorElement.style.position = 'fixed';
                errorElement.style.top = '20px';
                errorElement.style.right = '20px';
                errorElement.style.zIndex = '9999';
                errorElement.style.maxWidth = '400px';

                // æ·»åŠ å…³é—­æŒ‰é’®
                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.className = 'btn-close';
                closeButton.setAttribute('data-bs-dismiss', 'alert');
                closeButton.setAttribute('aria-label', 'Close');
                errorElement.appendChild(closeButton);

                document.body.appendChild(errorElement);
            }

            errorElement.innerHTML = `
                <strong>Error!</strong> ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;

            // 5ç§’åè‡ªåŠ¨å…³é—­
            setTimeout(() => {
                if (errorElement && errorElement.parentNode) {
                    errorElement.parentNode.removeChild(errorElement);
                }
            }, 5000);
        }

        function showInfo(message) {
            let infoElement = document.getElementById('info-message');
            if (!infoElement) {
                infoElement = document.createElement('div');
                infoElement.id = 'info-message';
                infoElement.className = 'alert alert-info alert-dismissible fade show';
                infoElement.style.position = 'fixed';
                infoElement.style.top = '20px';
                infoElement.style.right = '20px';
                infoElement.style.zIndex = '9999';
                infoElement.style.maxWidth = '400px';
                const closeButton = document.createElement('button');
                closeButton.type = 'button';
                closeButton.className = 'btn-close';
                closeButton.setAttribute('data-bs-dismiss', 'alert');
                closeButton.setAttribute('aria-label', 'Close');
                infoElement.appendChild(closeButton);
                document.body.appendChild(infoElement);
            }
            infoElement.innerHTML = `
                <strong>Notification</strong> ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            `;
            setTimeout(() => {
                if (infoElement && infoElement.parentNode) {
                    infoElement.parentNode.removeChild(infoElement);
                }
            }, 3000);
        }

    // --- Admin Chat Implementation ---
    const AdminChat = {
        activeSessionId: null,
        sessions: {},

        init() {
            this.cacheDOM();
            this.bindEvents();
            this.renderSidebar();
        },

        cacheDOM() {
            this.sidebarList = document.getElementById('cs-session-list');
            this.chatBody = document.getElementById('cs-messages');
            this.input = document.getElementById('cs-input');
            this.sendBtn = document.getElementById('cs-send-btn');
            this.totalActiveBadge = document.getElementById('cs-total-active');
            this.chatInterface = document.getElementById('cs-chat-interface');
            this.emptyState = document.getElementById('cs-empty-state');
            this.currentName = document.getElementById('cs-current-name');
            this.currentId = document.getElementById('cs-current-id');
            this.currentAvatar = document.getElementById('cs-current-avatar');
            this.currentStatus = document.getElementById('cs-current-status');
        },

        bindEvents() {
            if (this.sendBtn) {
                const newBtn = this.sendBtn.cloneNode(true);
                this.sendBtn.parentNode.replaceChild(newBtn, this.sendBtn);
                this.sendBtn = newBtn;
                this.sendBtn.addEventListener('click', () => this.sendMessage());
            }
            if (this.input) {
                const newInput = this.input.cloneNode(true);
                this.input.parentNode.replaceChild(newInput, this.input);
                this.input = newInput;
                this.input.addEventListener('keydown', (e) => { if (e.key === 'Enter') this.sendMessage(); });
            }
        },

        handleMessage(msg) {
            if (msg.type === 'clients') {
                this.updateSessionList(msg.clients);
            } else if (msg.type === 'sessions') {
                this.updateSessionList(msg.sessions);
            } else if (msg.type === 'message' || msg.type === 'question') {
                this.addMessage(msg.sessionId, msg, 'user');
            } else if (msg.type === 'reply') {
                this.addMessage(msg.sessionId, msg, 'admin');
            } else if (msg.type === 'session_ended') {
                const sid = msg.sessionId;
                if (sid && this.sessions[sid]) {
                    delete this.sessions[sid];
                    if (this.activeSessionId === sid) {
                        this.activeSessionId = null;
                        if (this.emptyState) this.emptyState.style.display = 'block';
                        if (this.chatInterface) this.chatInterface.style.display = 'none';
                    }
                    this.renderSidebar();
                    showInfo(`Session ${sid} ended`);
                }
            }
        },

        updateSessionList(clients) {
            if (!Array.isArray(clients)) return;
            const incoming = new Set(clients.map(c => c.sessionId));
            Object.keys(this.sessions).forEach(sid => { if (!incoming.has(sid)) delete this.sessions[sid]; });
            clients.forEach(c => {
                if (!this.sessions[c.sessionId]) {
                    this.sessions[c.sessionId] = {
                        user: c.user || { username: 'Guest' },
                        messages: [],
                        unread: 0,
                        lastActive: Date.now(),
                        status: c.status || 'active',
                        online: Number(c.online || 0)
                    };
                } else {
                    this.sessions[c.sessionId].user = c.user || this.sessions[c.sessionId].user;
                    this.sessions[c.sessionId].status = c.status || this.sessions[c.sessionId].status;
                    this.sessions[c.sessionId].online = Number(c.online || this.sessions[c.sessionId].online || 0);
                }
            });
            this.renderSidebar();
        },

        addMessage(sid, msg, sender) {
            if (!this.sessions[sid]) {
                this.sessions[sid] = { user: msg.user || { username: 'Guest' }, messages: [], unread: 0, lastActive: Date.now() };
            }
            const session = this.sessions[sid];
            session.messages.push({ content: msg.message, sender, time: msg.timestamp || new Date().toISOString() });
            session.lastActive = Date.now();
            if (this.activeSessionId === sid) {
                this.appendChatBubble(msg.message, sender, msg.timestamp);
                this.scrollToBottom();
            } else {
                session.unread++;
                this.renderSidebar();
            }
        },

        sendMessage() {
            if (!this.activeSessionId) return;
            const text = (this.input?.value || '').trim();
            if (!text) return;
            if (adminWs && adminWs.readyState === WebSocket.OPEN) {
                adminWs.send(JSON.stringify({ type: 'reply', sessionId: this.activeSessionId, message: text }));
                this.input.value = '';
            }
        },

        selectSession(sid) {
            this.activeSessionId = sid;
            const session = this.sessions[sid];
            if (session) {
                session.unread = 0;
                this.renderSidebar();
                this.renderChat(session);
                this.loadHistory(sid);
            }
        },

        async loadHistory(sid) {
            try {
                const res = await fetch(`/admin/api/chat/history/${sid}`, { credentials: 'include' });
                const data = await res.json();
                if (data.ok && data.history) {
                    const session = this.sessions[sid];
                    session.messages = data.history.map(h => ({ content: h.content, sender: h.sender, time: h.time }));
                    this.renderChat(session);
                }
            } catch (e) { console.error('Failed to load history', e); }
        },

        renderSidebar() {
            if (!this.sidebarList) return;
            this.sidebarList.innerHTML = '';
            const sorted = Object.keys(this.sessions).sort((a, b) => this.sessions[b].lastActive - this.sessions[a].lastActive);
            if (this.totalActiveBadge) this.totalActiveBadge.textContent = sorted.length;
            sorted.forEach(sid => {
                const s = this.sessions[sid];
                const item = document.createElement('div');
                item.className = `cs-session-item ${this.activeSessionId === sid ? 'active' : ''}`;
                item.onclick = () => this.selectSession(sid);
                const name = s.user.username || s.user.email || sid.slice(0,6);
                const lastMsg = s.messages.length ? s.messages[s.messages.length - 1].content : 'No messages';
                const avatarText = (name || 'U').slice(0,1).toUpperCase();
                item.innerHTML = `
                    <div class="cs-session-avatar">${avatarText}</div>
                    <div class="cs-session-info">
                        <div class="cs-session-name">${name} ${s.online?'<span style="color:#22c55e;">â—</span>':'<span style="color:#ef4444;">â—</span>'}</div>
                        <div class="cs-session-preview">${lastMsg}</div>
                    </div>
                    ${s.unread>0?`<div class="cs-unread-badge">${s.unread}</div>`:''}
                `;
                this.sidebarList.appendChild(item);
            });
        },

        renderChat(session) {
            if (!this.chatBody) return;
            if (this.emptyState) this.emptyState.style.display = 'none';
            if (this.chatInterface) this.chatInterface.style.display = 'flex';
            this.chatBody.innerHTML = '';
            const display = session.user.username || session.user.email || this.activeSessionId;
            if (this.currentName) this.currentName.textContent = display;
            if (this.currentId) this.currentId.textContent = this.activeSessionId;
            if (this.currentAvatar) this.currentAvatar.textContent = (display||'U').slice(0,1).toUpperCase();
            let controls = document.getElementById('cs-chat-controls');
            if (!controls && this.chatBody && this.chatBody.parentNode) {
                controls = document.createElement('div');
                controls.id = 'cs-chat-controls';
                controls.style.textAlign = 'right';
                const endBtn = document.createElement('button');
                endBtn.id = 'cs-end-session';
                endBtn.className = 'btn btn-sm btn-outline-danger';
                endBtn.textContent = 'End Session';
                endBtn.onclick = () => { if (adminWs && this.activeSessionId) adminWs.send(JSON.stringify({ type: 'end_session', sessionId: this.activeSessionId })); };
                controls.appendChild(endBtn);
                this.chatBody.parentNode.insertBefore(controls, this.chatBody);
            }
            session.messages.forEach(m => this.appendChatBubble(m.content, m.sender, m.time));
            this.scrollToBottom();
        },

        appendChatBubble(text, sender, time) {
            if (!this.chatBody) return;
            const isMe = sender === 'admin';
            const row = document.createElement('div');
            row.className = `cs-msg ${isMe ? 'me' : 'other'}`;
            const content = document.createElement('div');
            content.className = 'cs-msg-content';
            content.textContent = text;
            const t = document.createElement('div');
            t.className = 'cs-msg-time';
            t.textContent = this.formatTime(time);
            row.appendChild(content);
            row.appendChild(t);
            this.chatBody.appendChild(row);
        },

        formatTime(t) { if (!t) return ''; const d = new Date(t); return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}); },
        scrollToBottom() { if (this.chatBody) this.chatBody.scrollTop = this.chatBody.scrollHeight; }
    };

    // Overwrite existing functions
    function connectAdminWs() {
        const proto = location.protocol === 'https:' ? 'wss' : 'ws';
        adminWs = new WebSocket(`${proto}://${location.host}/admin/ws`);
        adminWs.onmessage = function (ev) {
            let msg; try { msg = JSON.parse(ev.data); } catch (_) { msg = { type: 'raw', data: ev.data }; }
            
            if (AdminChat) AdminChat.handleMessage(msg);

            if (msg.type === 'metrics') updateMetrics(msg.metrics);
            if (msg.type === 'clients') updateClients(msg.clients);
            if (msg.type === 'log') { appendLog(msg.log); if (msg.log && msg.log.level === 'error') appendErrorLog(msg.log.message || 'ERROR'); }
            if (msg.type === 'server_log') appendServerLog(msg.data || msg);
            if (msg.type === 'error_log') appendErrorLog(msg.data);
            if (msg.type === 'app_error') appendErrorLog(msg.data);
            if (msg.type === 'log_init' && Array.isArray(msg.logs)) { msg.logs.forEach(appendLog); }
        };
        // Reconnection logic could be added here
        adminWs.onclose = function() {
            setTimeout(connectAdminWs, 3000);
        };
    }

    function initializeCustomerService() {
        AdminChat.init();
    }
    </script>
